<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Memo</title>
    
    
    <meta content="Memo" name="keywords">
    
    <meta content="Memo - LLVM introduction (1) LLVM提供了完整編譯系統的中間層，
它會將中間語言（Intermediate Representation，IR）從編譯器取出與最佳化， 最佳化後的IR接著被轉換及鏈結到目標平台的汇编语言。
LLVM可以接受來自GCC工具鏈所編譯的IR，包含它底下現存的編譯器。 =&gt; 所以代表LLVM可以當作是gcc的backend
(2) LLVM也可以在編譯時期、鏈結時期，甚至是執行時期產生可重新定位的程式碼（Relocatable Code）。 (3) LLVM支援與語言無關的指令集架構及類型系統[7]。
每個在静态单赋值形式（SSA）的指令集代表著 每個變數（被稱為具有型別的暫存器）僅被賦值一次，這簡化了變數間相依性的分析
(4) LLVM允許程式碼被靜態的編譯，
包含在傳統的GCC系統底下，或是類似JAVA等後期編譯才將IF編譯成機器碼所使用的即時編譯（JIT）技術。
它的型別系統包含基本型別（整數或是浮点数）及五個複合型別（指標、数组、向量、結構及函數），
在LLVM具體語言的型別建制可以以結合基本型別來表示，
舉例來說，C&#43;&#43;所使用的class可以被表示為結構、函式及函数指针的陣列所組成。
(5) LLVM JIT編譯器可以最佳化在執行時期時程式所不需要的靜態分支，
這在一些部份求值（Partial Evaluation）的案例中相當有效，即當程式有許多選項，
而在特定環境下其中多數可被判斷為是不需要。這個特色被使用在Mac OS X Leopard（v10.5）底下OpenGL的管線，
當硬體不支援某個功能時依然可以被成功地運作[8]。OpenGL堆栈下的繪圖程式被編譯為IR，
接著在機器上執行時被編譯，當系統擁有高階GPU時，
這段程式會進行極少的修改並將傳遞指令給GPU，當系統擁有低階的GPU時，LLVM將會編譯更多的程序，
使這段GPU無法執行的指令在本地端的中央处理器執行。
LLVM增進了使用Intel GMA晶片等低端機器的效能。一個類似的系統發展於Gallium3D LLVMpipe，
它已被合併到GNOME，使其可運行在沒有GPU的環境
LLVM flow briefing 實驗了frontend=&gt;optimizer=&gt;backend的flow
LLVM 定義了一個通用的程式中介表示法，LLVM IR。LLVM IR 是一種類似機器語言，
但為了通用性以及給編譯器設計者方便而簡化的版本。在 LLVM 的世界裡，大家都講 LLVM IR：
Frontend 把原始語言的邏輯翻譯成 LLVM IR、
Optimizer 把 LLVM IR 整理成效率更好的 LLVM IR、
Backend 拿到 LLVM IR 來生成機器目標平台的機器語言。" name="description">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    

    

    

    
    
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>
    

    <link rel="stylesheet" href="/layui/css/layui.css">
    <link rel="stylesheet" href="/self/css/default.css">
    <script async src="/layui/layui.js"></script>

    <link rel="stylesheet" async href="/self/css/markdown.min.css">
    <link rel="stylesheet" async href="/self/css/gallery.css">
    
    
    

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous">
    <script async src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.0/lazysizes.min.js" integrity="sha256-h2tMEmhemR2IN4wbbdNjj9LaDIjzwk2hralQwfJmBOE=" crossorigin="anonymous"></script></head>

<body>
    
    <header class="layui-header layui-bg-cyan">

    
    
    <a class="nav-self-logo" href="/">
        Memo
    </a>

    <ul class="layui-nav layui-layout-right layui-bg-cyan" lay-filter="">
        
        
        <li class="layui-nav-item" id="nav_big"><a href="/post/">Posts</a></li>
        

        
            
                <li class="layui-nav-item" id="nav_big"><a href="/about/">About</a></li>
            
        

        
        <li class="layui-nav-item" id="nav_small">
            <a href="javascript:;">
                <i class="layui-icon layui-icon-app" style="font-size: 24px;"></i>
            </a>

            <dl class="layui-nav-child">
                
                <dd><a href="/post/">Posts</a></dd>
                

                
                    
                        <dd><a href="/about/">About</a></dd>
                    
                
            </dl>
        </li>
    </ul>
</header>

<script>
layui.use('element', function(){
  var element = layui.element;
});
</script>
        <div id="content" style="min-height:80%">
<div class="layui-container" style="margin-bottom: 10px">
    

    <div class="layui-row layui-col-space10">
        <div class="layui-col-md12 layui-col-sm12 layui-col-xs12">
            <div class="layui-card single-card">
                <br />
                <blockquote class="self-elem-quote self-elem-quote-bg-red markdown-body single-title" >
                    <h1></h1>
                    <h3 style="margin-top:10px; margin-bottom:10px"> 
    <i class="layui-icon layui-icon-date" style="font-size: 28px; vertical-align: -2px;"></i>
    <span>0001-01-01</span>

    
     
    <i class="layui-icon layui-icon-list" style="font-size: 32px; vertical-align: -3px;"></i>
    

    
        <a href="/categories/compiler-framework-llvm/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">COMPILER-FRAMEWORK-LLVM</span>
        </a>
    

    
    
    
</h3>
                </blockquote>
                <div class="layui-card-body markdown-body single-content">
                    <h1 id="llvm-introduction">LLVM introduction</h1>
<p>(1) LLVM提供了完整編譯系統的中間層，<br>
它會將中間語言（Intermediate Representation，IR）從編譯器取出與最佳化， <br>
最佳化後的IR接著被轉換及鏈結到目標平台的汇编语言。<br>
LLVM可以接受來自GCC工具鏈所編譯的IR，包含它底下現存的編譯器。  <br>
=&gt; 所以代表LLVM可以當作是gcc的backend</p>
<p>(2) LLVM也可以在編譯時期、鏈結時期，甚至是執行時期產生可重新定位的程式碼（Relocatable Code）。 <br>
(3) LLVM支援與語言無關的指令集架構及類型系統[7]。<br>
<strong>每個在静态单赋值形式（SSA）的指令集代表著</strong>      <br>
<strong>每個變數（被稱為具有型別的暫存器）僅被賦值一次，這簡化了變數間相依性的分析</strong></p>
<p>(4) LLVM允許程式碼被靜態的編譯，<br>
包含在傳統的GCC系統底下，或是類似JAVA等後期編譯才將IF編譯成機器碼所使用的即時編譯（JIT）技術。<br>
它的型別系統包含基本型別（整數或是浮点数）及五個複合型別（指標、数组、向量、結構及函數），<br>
在LLVM具體語言的型別建制可以以結合基本型別來表示，<br>
舉例來說，C++所使用的class可以被表示為結構、函式及函数指针的陣列所組成。</p>
<p>(5) LLVM JIT編譯器可以最佳化在執行時期時程式所不需要的靜態分支，<br>
這在一些部份求值（Partial Evaluation）的案例中相當有效，即當程式有許多選項，<br>
而在特定環境下其中多數可被判斷為是不需要。這個特色被使用在Mac OS X Leopard（v10.5）底下OpenGL的管線，<br>
當硬體不支援某個功能時依然可以被成功地運作[8]。OpenGL堆栈下的繪圖程式被編譯為IR，<br>
接著在機器上執行時被編譯，當系統擁有高階GPU時，<br>
這段程式會進行極少的修改並將傳遞指令給GPU，當系統擁有低階的GPU時，LLVM將會編譯更多的程序，<br>
使這段GPU無法執行的指令在本地端的中央处理器執行。<br>
LLVM增進了使用Intel GMA晶片等低端機器的效能。一個類似的系統發展於Gallium3D LLVMpipe，<br>
它已被合併到GNOME，使其可運行在沒有GPU的環境</p>
<h1 id="llvm-flow-briefing">LLVM flow briefing</h1>
<p>實驗了frontend=&gt;optimizer=&gt;backend的flow<br>
<img src="https://github.com/evansin100/LLVM-and-IR/blob/master/Selection_016.png" alt="image"><br>
LLVM 定義了一個通用的程式中介表示法，LLVM IR。LLVM IR 是一種類似機器語言，<br>
但為了通用性以及給編譯器設計者方便而簡化的版本。在 LLVM 的世界裡，大家都講 LLVM IR：<br>
Frontend 把原始語言的邏輯翻譯成 LLVM IR、<br>
Optimizer 把 LLVM IR 整理成效率更好的 LLVM IR、<br>
Backend 拿到 LLVM IR 來生成機器目標平台的機器語言。<br>
如此一來，無論是語言設計者想要創造一個新語言、演算法設計師想改進程式的效能、<br>
或是硬體或虛擬機製造者要做一個新的平台，都能得益於 LLVM 的世界，<br>
新語言只要設計好 frontend parser 就能使用現有的 optimizer 技術並編譯到各種不同平台、<br>
新的 optimizer 可以套用在各種語言和平台的編譯器上、新硬體或虛擬機只要支援 LLVM IR 就可以在上面跑各種主流語言</p>
</div>
            </div>
        </div>

        
    </div>
</div>


        </div><footer>
    

    <div class="layui-container">
        <div class="layui-row">
            <div class="layui-col-md4 layui-col-sm6 layui-col-xs6">
                <h3> Related Sites </h3>
            </div>
        </div>
        <div class="layui-row">
            
            <div class="layui-col-md4 layui-col-sm6 layui-col-xs12">
                <a href="/"><p class="footer-url">home</p></a>
            </div>
            
            <div class="layui-col-md4 layui-col-sm6 layui-col-xs12">
                <a href="/about/"><p class="footer-url">About</p></a>
            </div>
            
        </div>
    </div>
    
    
    <div class="layui-container">
        <p class="copyright">&copy; All rights reserved. Powered by <a href='https://gohugo.io' style='color:#FFFFFF'>Hugo</a> and <a href='https://github.com/ertuil/erblog' style='color:#FFFFFF'>Erblog</a>.</p>
    </div>
</footer>
</body>
</html>
