<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>COMPILER-Concept on Memo</title>
    <link>https://evansin100.github.io/categories/compiler-concept/</link>
    <description>Recent content in COMPILER-Concept on Memo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    
	<atom:link href="https://evansin100.github.io/categories/compiler-concept/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://evansin100.github.io/post/compiler-concept/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://evansin100.github.io/post/compiler-concept/readme/</guid>
      <description>Concept 簡言之，編譯器獲取原始碼，產生一個二進位制檔案。
因為從複雜的、人類可讀的程式碼直接轉化成0/1二進位制會很複雜， 所以編譯器在產生可執行程式之前有多個步驟：
Lexer 詞法分析
(1) 输入：一堆字符，即我们写的语法代码，一个文件，也就是一堆字符；
(2) 经过lexer处理；
(3) 输出：一系列的token，相当于一堆的变量或者说符号；
第一步是把輸入一個詞一個詞的拆分開。
這一步被叫做 詞法分析,或者說是分詞。
這一步的關鍵就在於 我們把字元組合成我們需要的單詞、識別符號、符號等等。 詞法分析大多都不需要處理邏輯運算像是算出 2+2 –
其實這個表示式只有三種 標記：一個數字：2,一個加號，另外一個數字：2
Parser(output AST) 解析器確實是語法解析的核心。
解析器提取由詞法分析器產生的標記，並嘗試判斷它們是否符合特定的模式，
然後把這些模式與函式呼叫，變數呼叫，數學運算之類的表示式關聯起來。 解析器逐詞地定義程式語言的語法
你可以寫好幾種不同型別的解析器。
最常見的解析器之一是從上到下的，遞迴降解的解析器。
遞迴降解的解析器是用起來最簡單也是最容易理解的解析器
解析器在解析時產生的樹狀結構被稱為 抽象的語法樹，或者稱之為 AST。
 AST 的全文是 Abstract Syntax Tree，中文大多翻作抽象語法樹， 主要是將我們 人類 所寫的程式語法，轉換成 程式 比較容易閱讀的語法結構，並以樹的資料結構來儲存
ast 中包含了所有要進行操作。解析器不會計算這些操作，它只是以正確的順序來收集其中的標記。
我之前補充了我們的詞法分析器程式碼，以便它與我們的語法想匹配，並且可以產生像圖表一樣的 AST  Optional: AST =&amp;gt; more IR 編譯器可能有 中間表示,或者簡稱 IR 。 IR 主要是為了在優化或者翻譯成另一門語言的時候，無損地表示原來的指令。
IR 不再是原來的程式碼；IR 是為了尋找程式碼中潛在的優化而進行的無損簡化。
迴圈展開 和 向量化 都是利用 IR 完成的 =&amp;gt; IR可以做更低階的優化</description>
    </item>
    
  </channel>
</rss>