<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HW-INFO-SIMD_SIMT on Memo</title>
    <link>https://evansin100.github.io/categories/hw-info-simd_simt/</link>
    <description>Recent content in HW-INFO-SIMD_SIMT on Memo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    
	<atom:link href="https://evansin100.github.io/categories/hw-info-simd_simt/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://evansin100.github.io/post/hw-info-simd_simt/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://evansin100.github.io/post/hw-info-simd_simt/readme/</guid>
      <description>Summary  (1) CPU就是SIMD(NEON instruction)   (1) 一個execution engine/cluster內的threads可以執行同個OpenCL kernel指令 =&amp;gt; SIMT (3) 每個thread可以發一個FMA依然可以處理多個資料指令 =&amp;gt; SIMD   (1) 通常DSP都是VLIW processor,一個instruction,可以有多筆的operation(slot) =&amp;gt; VLIW (2) 然後處理有個slot可以處理vector指令(SIMD) =&amp;gt; SIMD  SIMT Concept SIMT就是GPU,有multiple &amp;ldquo;thread&amp;rdquo;
SIMD就是一般的vector運算,還是只有一個thread但可以處理多筆data
SIMT中文译为单指令多线程，英文全称为Single Instruction Multiple Threads
GPU中的SIMT体系结构相对于CPU的SIMD中的概念。为了有效地管理和执行多个单线程，多处理器采用了SIMT架构。
不同于CPU中通过SIMD（单指令多数据）来处理矢量数据；
GPU则使用SIMT，SIMT的好处是无需开发者费力把数据凑成合适的矢量长度，
并且SIMT允许每个线程有不同的分支。 纯粹使用SIMD不能并行的执行有条件跳转的函数，
很显然条件跳转会根据输入数据不同在不同的线程中有不同表现， 这个只有利用SIMT才能做到。
SIMT/SIMD Comparison 不同於CPU中通過SIMD（單指令多資料）來處理向量資料；GPU則使用SIMT，
SIMT的好處是無需開發者費力把資料湊成合適的向量長度 =&amp;gt; 這個是優點，並且SIMT允許每個執行緒有不同的分支。 純粹使用SIMD不能並行的執行有條件跳轉的函式，
很顯然條件跳轉會根據輸入資料不同在不同的執行緒中有不同表現，這個只有利用SIMT才能做到。
在SIMT程式設計模型中如果需要控制單個執行緒的行為，必須使用分支，這會大大的降低效率。
例如，如果一個warp中需要進行分支（即warp內的執行緒執行的指令指標指向不同的位置），效能將急劇的下降 =&amp;gt;所以要避免if else, for loop判斷,因為會有sync問題 GPU(SIMT)的缺點
 (1) 平行不夠高，效能不會好：GPU 的運算單元數量很多，不能高度平行化的工作，所能帶來的效益就不高。 (2) 只適合一路油門踩到底：GPU 通常沒有分支預測等複雜的輔助流程控制單元（就算有，也會很慢  </description>
    </item>
    
  </channel>
</rss>